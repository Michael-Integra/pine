# 2020-03-02 Design Migrations

Since the compilation interface to generate JSON coding functions is now implemented, I am wondering what the next feature to implement is. Migrations are still a tedious manual process, so these could be next. At the moment, this looks more valuable than getting rid of the Javascript problems on the backend. Reference for judging value/effectiveness still is the typical MMO game development process.

So far, I have done migrations manually, using the interface to read and set the backend state. Mapping the serialized representation of the backend state from the old Elm type to the new one was done using a custom program.

How should migrations work in the future? Here is my guess for today, writing down some of what has accumulated during the last weeks/months:

+ Migrations are atomic, and the history chain reflects the migration with a specific event.
+ How does the production system know how to migrate the backend state? When attempting a migration, we supply an Elm function to map from the old backend state to the new one. This function is contained in an Elm module which imports Elm modules defining the old backend state type and Elm modules defining the new backend state type. (In today's serial representation of Elm values, module names are not reflected in custom type tags. As a result, moving a module containing a custom type into another directory does not affect its representation.) How do we write all that migration code? The first step is to let the development tool generate the parts we need in any case: All the Elm modules defining the Elm types. The history of the project can contain many versions of the backend state model, and we often don't migrate from the last one. We can pick the source version, for example, by specifying the identifier of the app version to migrate from. We can look up the version identifier in the admin interface. Remember: The app version id is a hash over all app code files. So this hash can be different for versions which use the same backend state type. This distinction is necessary because sometimes we want to migrate the state to account for new function implementations treating the values differently.
+ How does the production server receive the new app and the migration code? We reuse the admin interface for this purpose. We could use the HTTP API to upload a zip-archive containing all the info needed for the migration.
+ Supporting migrations only for the backend app is not necessary. Instead use an approach closer to the expected long-term solution: Include the frontend and static files parts in any case.
+ The production server checks if the provided information is consistent and if the migration is applicable for the current state. In case the migration does not work out, the server continues regular operation with the app as before.

All in all, I see a pragmatic solution that still applies special treatment to distinguish between backend app and the rest on a framework level. (The backend Elm app still runs using a Javascript engine).
